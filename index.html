<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast Puzzle</title>
    <style>
        :root {
            --bg-color: #1a237e; /* Dark Blue like reference */
            --grid-bg: #0d1245;
            --cell-size: 40px; /* Base size, will be responsive */
            --gap: 3px;
        }

        * {
            box-sizing: border-box;
            touch-action: none; /* Prevent scrolling while playing */
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        /* --- HEADER & SCORE --- */
        .header {
            width: 100%;
            max-width: 400px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .score-container {
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .score-label {
            font-size: 1rem;
            color: #ffd700; /* Gold */
        }

        /* --- GRID AREA --- */
        .game-board {
            background-color: var(--grid-bg);
            padding: 10px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: var(--gap);
            width: 90vw;
            max-width: 400px;
            aspect-ratio: 1/1;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .cell {
            background-color: #283593; /* Empty cell color */
            border-radius: 4px;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Filled cell styling */
        .cell.filled {
            background-size: cover;
            background-position: center;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        
        /* Highlight drop zone */
        .cell.highlight {
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* Animation for clearing */
        .cleared {
            animation: popOut 0.3s forwards;
        }

        @keyframes popOut {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* --- DOCK / SPAWN AREA --- */
        .dock {
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
            height: 150px;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .dock-slot {
            width: 30%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- DRAGGABLE PIECES --- */
        .piece {
            display: grid;
            gap: 2px;
            /* Default scale down in dock */
            transform: scale(0.6); 
            transition: transform 0.1s;
            cursor: grab;
        }

        .piece-block {
            width: 30px; /* Visual size in dock */
            height: 30px;
            border-radius: 3px;
            background-size: cover;
        }

        /* Style when dragging */
        .piece.dragging {
            position: fixed;
            z-index: 1000;
            pointer-events: none; /* Let events pass through to grid */
            transform: scale(1.1); /* Scale up slightly when dragging */
            opacity: 0.9;
        }

        /* Responsive */
        @media (min-width: 450px) {
            :root {
                --cell-size: 45px;
            }
            .piece-block {
                width: 40px;
                height: 40px;
            }
        }
        
        /* Modal Game Over */
        #game-over {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        #game-over h1 { color: white; margin-bottom: 20px; }
        .btn-restart {
            padding: 15px 30px;
            background: #ff0055;
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 0 15px #ff0055;
        }

    </style>
</head>
<body>

    <div class="header">
        <div class="score-label">BEST: <span id="best-score">0</span></div>
        <div class="score-container">
            <span>❤️</span>
            <span id="score">0</span>
        </div>
    </div>

    <div class="game-board" id="grid">
        </div>

    <div class="dock" id="dock">
        <div class="dock-slot" id="slot-0"></div>
        <div class="dock-slot" id="slot-1"></div>
        <div class="dock-slot" id="slot-2"></div>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <div style="font-size: 2rem; margin-bottom: 20px; color: #ffd700;" id="final-score">0</div>
        <button class="btn-restart" onclick="resetGame()">Try Again</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const GRID_SIZE = 8;
        const ASSETS = [
            'https://res.cloudinary.com/dsutaioqw/image/upload/v1770908103/block1_rgsmm5.png',
            'https://res.cloudinary.com/dsutaioqw/image/upload/v1770908103/block2_bctdq8.png',
            'https://res.cloudinary.com/dsutaioqw/image/upload/v1770908103/block3_lt4n75.png',
            'https://res.cloudinary.com/dsutaioqw/image/upload/v1770908102/block4_h3yano.png',
            'https://res.cloudinary.com/dsutaioqw/image/upload/v1770908103/block5_d0pye8.png'
        ];

        // Shapes Definition (Matrix: 1 = block, 0 = empty)
        const SHAPES = [
            { m: [[1]], id: 'single' },
            { m: [[1,1]], id: 'h2' },
            { m: [[1],[1]], id: 'v2' },
            { m: [[1,1,1]], id: 'h3' },
            { m: [[1],[1],[1]], id: 'v3' },
            { m: [[1,1,1,1]], id: 'h4' },
            { m: [[1],[1],[1],[1]], id: 'v4' },
            { m: [[1,1],[1,1]], id: 'square' },
            { m: [[1,0],[1,1]], id: 'L1' },
            { m: [[0,1],[1,1]], id: 'L2' },
            { m: [[1,1],[1,0]], id: 'L3' },
            { m: [[1,1],[0,1]], id: 'L4' },
            { m: [[1,1,1],[0,1,0]], id: 'T1' },
            { m: [[0,1,0],[1,1,1]], id: 'T2' }
        ];

        // --- STATE ---
        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
        let score = 0;
        let bestScore = localStorage.getItem('blockBlastBest') || 0;
        document.getElementById('best-score').innerText = bestScore;

        // --- INIT ---
        const gridEl = document.getElementById('grid');
        const dockEl = document.getElementById('dock');
        
        function initGrid() {
            gridEl.innerHTML = '';
            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    gridEl.appendChild(cell);
                }
            }
        }

        // --- GAME LOGIC ---

        function spawnPieces() {
            const slots = [0, 1, 2];
            slots.forEach(i => {
                const slot = document.getElementById(`slot-${i}`);
                if (slot.childElementCount === 0) {
                    const shapeData = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                    const texture = ASSETS[Math.floor(Math.random() * ASSETS.length)]; // Random color
                    createDraggablePiece(slot, shapeData.m, texture);
                }
            });
            checkGameOver();
        }

        function createDraggablePiece(container, matrix, textureUrl) {
            const piece = document.createElement('div');
            piece.classList.add('piece');
            piece.style.gridTemplateColumns = `repeat(${matrix[0].length}, 1fr)`;
            piece.dataset.matrix = JSON.stringify(matrix);
            piece.dataset.texture = textureUrl;

            // Generate blocks inside piece
            matrix.forEach((row, r) => {
                row.forEach((val, c) => {
                    const block = document.createElement('div');
                    if (val === 1) {
                        block.classList.add('piece-block');
                        block.style.backgroundImage = `url('${textureUrl}')`;
                        // Background color fallback/tint
                        block.style.backgroundColor = getDominantColor(textureUrl); 
                    } else {
                        block.style.width = '30px'; 
                        block.style.height = '30px';
                        block.style.visibility = 'hidden';
                    }
                    piece.appendChild(block);
                });
            });

            // Event Listeners
            piece.addEventListener('mousedown', handleDragStart);
            piece.addEventListener('touchstart', handleDragStart, {passive: false});

            container.appendChild(piece);
        }

        // --- DRAG AND DROP LOGIC ---
        let draggedPiece = null;
        let originalParent = null;
        let dragOffset = {x:0, y:0};
        let currentMatrix = null;
        let currentTexture = null;

        function handleDragStart(e) {
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const target = e.currentTarget;

            draggedPiece = target;
            originalParent = target.parentElement;
            currentMatrix = JSON.parse(target.dataset.matrix);
            currentTexture = target.dataset.texture;

            // Calculate offset to grab from center/touch point
            const rect = target.getBoundingClientRect();
            dragOffset.x = touch.clientX - rect.left - (rect.width / 2); // Center grab
            dragOffset.y = touch.clientY - rect.top - (rect.height / 2);

            // Move to body for absolute positioning
            draggedPiece.classList.add('dragging');
            document.body.appendChild(draggedPiece);
            
            // Initial position update
            movePiece(touch.clientX, touch.clientY);

            // Add global move/up listeners
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('touchmove', handleDragMove, {passive: false});
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('touchend', handleDragEnd);
        }

        function handleDragMove(e) {
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            movePiece(touch.clientX, touch.clientY);
            
            // Highlight potential drop
            const gridInfo = getGridUnderPiece(touch.clientX, touch.clientY);
            clearHighlights();
            if (gridInfo && canPlace(gridInfo.r, gridInfo.c, currentMatrix)) {
                highlightGrid(gridInfo.r, gridInfo.c, currentMatrix);
            }
        }

        function movePiece(x, y) {
            if(!draggedPiece) return;
            // Visual size needs to match grid cell size roughly when dragging
            // Scale is handled in CSS, but position needs to center on finger
            draggedPiece.style.left = (x - (draggedPiece.offsetWidth / 2)) + 'px';
            draggedPiece.style.top = (y - (draggedPiece.offsetHeight / 2) - 50) + 'px'; // -50 to see under finger
        }

        function handleDragEnd(e) {
            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const gridInfo = getGridUnderPiece(touch.clientX, touch.clientY);
            
            clearHighlights();

            let placed = false;
            if (gridInfo && canPlace(gridInfo.r, gridInfo.c, currentMatrix)) {
                placePiece(gridInfo.r, gridInfo.c, currentMatrix, currentTexture);
                draggedPiece.remove(); // Remove draggable
                score += currentMatrix.flat().filter(x=>x).length * 10;
                updateScore();
                checkLines();
                spawnPieces(); // Check if dock empty
                placed = true;
            } else {
                // Return to dock
                draggedPiece.classList.remove('dragging');
                draggedPiece.style.left = '';
                draggedPiece.style.top = '';
                originalParent.appendChild(draggedPiece);
            }

            // Cleanup
            draggedPiece = null;
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('touchmove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.removeEventListener('touchend', handleDragEnd);
        }

        // --- GRID HELPERS ---

        function getGridUnderPiece(x, y) {
            // We want the grid cell closest to the top-left of the piece's first block
            // However, the finger is usually in the center of the piece. 
            // Let's sample the grid element directly under the finger (with offset adjustment)
            
            // Simply hide piece momentarily to get element below
            if(draggedPiece) draggedPiece.style.visibility = 'hidden';
            const elemBelow = document.elementFromPoint(x, y - 50);
            if(draggedPiece) draggedPiece.style.visibility = 'visible';

            if (!elemBelow) return null;
            
            // If we hit a cell
            if (elemBelow.classList.contains('cell')) {
                return { 
                    r: parseInt(elemBelow.dataset.r), 
                    c: parseInt(elemBelow.dataset.c) 
                };
            }
            return null;
        }

        function canPlace(startR, startC, matrix) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if (matrix[r][c] === 1) {
                        const targetR = startR + r;
                        const targetC = startC + c;
                        // Check bounds
                        if (targetR >= GRID_SIZE || targetC >= GRID_SIZE) return false;
                        // Check occupancy
                        if (grid[targetR][targetC] !== null) return false;
                    }
                }
            }
            return true;
        }

        function highlightGrid(startR, startC, matrix) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if (matrix[r][c] === 1) {
                        const cell = document.querySelector(`.cell[data-r="${startR+r}"][data-c="${startC+c}"]`);
                        if(cell) cell.classList.add('highlight');
                    }
                }
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        }

        function placePiece(startR, startC, matrix, texture) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if (matrix[r][c] === 1) {
                        const targetR = startR + r;
                        const targetC = startC + c;
                        grid[targetR][targetC] = texture;
                        
                        const cell = document.querySelector(`.cell[data-r="${targetR}"][data-c="${targetC}"]`);
                        cell.classList.add('filled');
                        cell.style.backgroundImage = `url('${texture}')`;
                    }
                }
            }
        }

        // --- CLEAR LINES LOGIC ---
        function checkLines() {
            let linesCleared = 0;
            const rowsToClear = [];
            const colsToClear = [];

            // Check Rows
            for(let r=0; r<GRID_SIZE; r++) {
                if (grid[r].every(val => val !== null)) rowsToClear.push(r);
            }

            // Check Cols
            for(let c=0; c<GRID_SIZE; c++) {
                let full = true;
                for(let r=0; r<GRID_SIZE; r++) {
                    if(grid[r][c] === null) { full = false; break; }
                }
                if(full) colsToClear.push(c);
            }

            // Visual Clear & Data Clear
            const cellsToAnimate = new Set();

            rowsToClear.forEach(r => {
                for(let c=0; c<GRID_SIZE; c++) {
                    cellsToAnimate.add(`${r},${c}`);
                    grid[r][c] = null;
                }
            });

            colsToClear.forEach(c => {
                for(let r=0; r<GRID_SIZE; r++) {
                    cellsToAnimate.add(`${r},${c}`);
                    grid[r][c] = null;
                }
            });

            if (cellsToAnimate.size > 0) {
                cellsToAnimate.forEach(coord => {
                    const [r, c] = coord.split(',');
                    const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                    cell.classList.add('cleared');
                    // Remove visuals after anim
                    setTimeout(() => {
                        cell.classList.remove('filled', 'cleared');
                        cell.style.backgroundImage = '';
                    }, 300);
                });
                
                // Score Calculation (Combo bonus)
                const totalLines = rowsToClear.length + colsToClear.length;
                score += (totalLines * 100) * totalLines; // Exponential bonus
                updateScore();
            }
        }

        // --- GAME OVER CHECK ---
        function checkGameOver() {
            // Get current pieces in dock
            const slots = document.querySelectorAll('.dock-slot .piece');
            if (slots.length === 0) return; // No pieces left (spawning next)

            let canMove = false;

            // Brute force check: Can ANY piece fit ANYWHERE?
            for (let piece of slots) {
                const matrix = JSON.parse(piece.dataset.matrix);
                
                for(let r=0; r<GRID_SIZE; r++) {
                    for(let c=0; c<GRID_SIZE; c++) {
                        if (canPlace(r, c, matrix)) {
                            canMove = true;
                            break;
                        }
                    }
                    if(canMove) break;
                }
                if(canMove) break;
            }

            if (!canMove) {
                setTimeout(() => {
                    document.getElementById('game-over').style.display = 'flex';
                    document.getElementById('final-score').innerText = score;
                    if(score > bestScore) {
                        localStorage.setItem('blockBlastBest', score);
                    }
                }, 500);
            }
        }

        function updateScore() {
            document.getElementById('score').innerText = score;
        }

        function resetGame() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            score = 0;
            updateScore();
            initGrid();
            document.getElementById('slot-0').innerHTML = '';
            document.getElementById('slot-1').innerHTML = '';
            document.getElementById('slot-2').innerHTML = '';
            document.getElementById('game-over').style.display = 'none';
            bestScore = localStorage.getItem('blockBlastBest') || 0;
            document.getElementById('best-score').innerText = bestScore;
            spawnPieces();
        }

        function getDominantColor(url) {
            // Simple mapping based on URL content string to give a tint
            if(url.includes('block1')) return '#e91e63';
            if(url.includes('block2')) return '#2196f3';
            if(url.includes('block3')) return '#4caf50';
            if(url.includes('block4')) return '#ff9800';
            if(url.includes('block5')) return '#9c27b0';
            return '#607d8b';
        }

        // Start
        initGrid();
        spawnPieces();

    </script>
</body>
</html>
